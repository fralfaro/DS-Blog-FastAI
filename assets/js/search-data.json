{
  
    
        "post0": {
            "title": "Jupyter Book",
            "content": "Introducci&#243;n . Jupyter Book es un proyecto de código abierto para crear libros y documentos mediante Jupyter Notebooks y/o Markdown. . Algunas características importantes del uso de Jupyter Book: . contenido con calidad de publicación que incluya figuras, símbolos matemáticos, citas y referencias cruzadas! | escribir contenido como Jupyter Notebooks, markdown o reStructuredText | Agregue interactividad a su libro, por ejemplo, alternar la visibilidad de las celdas, conectarse con un servicio en línea como Binder e incluir resultados interactivos (por ejemplo, figuras y widgets). | generar una variedad de resultados, incluidos sitios web (HTML, CSS, JS), markdown y PDF. | una interfaz de línea de comandos para crear libros rápidamente, por ejemplo, jupyter-book build mybook | . En esta sesión, se muestra un ejemplo de cómo crear un Jupyter Book desde cero y algunas de las características clave que ofrece Jupyter Book. . Nota:Puede encontrar los códigos de este ejemplo en el siguiente repositorio. Por otro lado, puede revisar el siguente link para ver la compilación con GitLab CI/CD. . Primeros pasos . Instalaci&#243;n . Para instalar Jupyter Book, necesitará usar la línea de comando. Si ha instalado Anaconda, puede usar: . conda install -c conda-forge jupyter-book . De lo contrario, puede instalar con pip: . pip install jupyter-book . Crear una estructura de libro . Jupyter Book viene con una herramienta que le permite crear y construir libros rápidamente. Para crear el esqueleto del libro, escriba lo siguiente en la línea de comando: . jupyter-book create jupiter . Nota:Aquí llamamos al libro jupiter, pero puedes elegir llamar a tu libro como quieras. . Ahora tendrás un nuevo directorio llamado jupiter (o como quieras llamar a tu libro), con el siguiente contenido: . jupiter ├── _config.yml ├── _toc.yml ├── content.md ├── intro.md ├── markdown.md ├── notebooks.ipynb ├── references.bib └── requirements.txt . Re-estructuraci&#243;n del directorio . Jupyter Book admite varios tipos de archivos: . Markdown (.md) | notebooks (.ipynb) | etc. | . Como Markdown y Jupyter Notebooks probablemente serán los tipos de archivo más comunes que usará, se mostrará un ejemplo de ello. . Lo primero será eliminar los archivos de inicio en el directorio: . content.md | intro.md | markdown.md | notebooks.ipynb | . Así que ejecutamos por línea de comando: . rm content.md intro.md markdown.md notebooks.ipynb . Agregar un archivo Markdown . Se comienza por agregar un archivo de markdown. Con algún editor a elección (por ejemplo, jupyter notebook o jupyterlab) se crea un nuevo archivo markdown llamado Introduction.md. . Se usa este archivo como demostración de algunos de los principales tipos de contenido que puede agregar en Jupyter-Book. . Texto . Se agrega un texto de Markdown simple a nuestro archivo. Si no está familiarizado con la sintaxis de markdown, consulte Markdown Cheat Sheet. Puede copiar y pegar el siguiente contenido directamente en su archivo Introduction.md. . # Jupiter Book This book contains information about the planet **Jupiter** - the fifth planet from the sun and the largest planet in the solar system! . Figuras . Puedes incluir figuras en tu Jupyter Book usando la siguiente sintaxis: . {figure} my_image.png height: 150px name: my-image Here is my image&#39;s caption! . Si bien la imagen puede estar contenida y referenciada desde el directorio raíz, también se puede incluir imágenes a través de URL. Incluyamos una imagen del planeta Júpiter en nuestro archivo Introduction.md usando lo siguiente: . {figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg height: 300px name: jupiter-figure The beautiful planet Jupiter! La razón por la que le damos un &quot;nombre&quot; a nuestra imagen es para que podamos hacer referencia a ella fácilmente con la sintaxis: {numref}`jupiter-figure` . Se agregará una oración que incluya esta referencia. El archivo completo ahora debería verse así: . # Jupiter Book This book contains information about the planet Jupiter - the fifth planet from the sun and the largest planet in the solar system! {numref}`jupiter-figure` below shows an image of Jupiter captured by the Hubble Space Telescope on June 27, 2019. {figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg height: 300px name: jupiter-figure The beautiful planet Jupiter! Source: [NASA](https://solarsystem.nasa.gov/resources/2486/hubbles-new-portrait-of-jupiter/?category=planets_jupiter). . En este punto, probablemente se debería crear nuetro libro para asegurarnos de que tenga el aspecto esperado. Para hacer eso, primero necesitamos modificar nuestro archivo _toc.yml. Este archivo contiene la tabla de contenido de nuestro libro. Abra ese archivo ahora y elimine todo lo que hay allí. Luego, simplemente agregue lo siguiente: . - file: introduction . Ahora podemos construir nuestro libro desde la línea de comandos asegurándonos de que estamos en el directorio raíz de nuestro libro y luego usando: . jupyter-book build . . Una vez finalizada la compilación, tendrá un nuevo subdirectorio llamado_build/html/ en la raíz de su libro, navegue hasta esa ubicación y abra _build/html/index.html. Debería verse algo como esto: . . Equaciones matem&#225;ticas . Jupyter Book usa MathJax para componer matemáticas, lo que le permite agregar matemáticas de estilo LaTeX a su libro. Puede agregar matemáticas en línea, bloques matemáticos y ecuaciones numeradas a su libro Jupyter. Sigamos adelante y creemos un nuevo encabezado en nuestro archivo Introduction.md que incluye algunas matemáticas. . Las matemáticas en línea se pueden definir usando $ de la siguiente manera: . Jupiter has a mass of: $m_{j} approx 1.9 times 10^{27} kg$ . Jupiter has a mass of: $m_{j} approx 1.9 times 10^{27} kg$ . Los bloques matemáticos se pueden definir usando la notación $$: . $$m_{j} approx 1.9 times 10^{27} kg$$ . $$m_{j} approx 1.9 times 10^{27} kg$$ . Nota:Si lo prefiere, los bloques matemáticos también se pueden definir con begin{equation} en lugar de $$. Las ecuaciones numeradas se pueden definir así (este es el estilo que te recomiendo que uses con más frecuencia): . {math} :label: my_label m_{j} approx 1.9 times 10^{27} kg . Agreguemos más contenido a nuestro libro. Copie y agregue el siguiente texto a su archivo Introduction.md: . ## The Mass of Jupiter We can estimate the mass of Jupiter from the period and size of an object orbiting it. For example, we can use Jupiter&#39;s moon Callisto to estimate it&#39;s mass. Callisto&#39;s period: $p_{c}=16.7 days$ Callisto&#39;s orbit radius: $r_{c}=1,900,000 km$ Now, using [Kepler&#39;s Law](https://solarsystem.nasa.gov/resources/310/orbits-and-keplers-laws/) we can work out the mass of Jupiter. {math} :label: eq1 m_{j} approx frac{r_{c}}{p_{c}} times 7.9 times 10^{10} {math} :label: eq2 m_{j} approx 1.9 times 10^{27} kg . A continuación, puede reconstruir su libro (jupyter-book build .) y abrir _build/html/index.html para asegurarse de que todo se esté procesando como se esperaba. . Controlando el dise&#241;o de la p&#225;gina . Hay varias formas diferentes de controlar el diseño de las páginas de su Jupyter Book. El cambio de diseño que utilizo con más frecuencia es agregar contenido a un margen en la página. Puede agregar un margen usando la siguiente directiva: . {margin} An optional title Some margin content. . Agreguemos algo de contenido marginal al libro: . {margin} Did you know? Jupiter is 11.0x larger than Earth! . Advertencias . Hay todo tipo de advertencias diferentes que puede usar en Jupyter Book que se enumeran aquí en la documentación de Jupyter Book. Las advertencias se crean con la sintaxis: . {note} I am a useful note! . No dude en agregar la siguiente advertencia a Introduction.md: . {hint} NASA provides a lot more information about the physical characteristics of Jupiter [here](https://solarsystem.nasa.gov/planets/jupiter/by-the-numbers/). . Citas y bibliograf&#237;a . El último contenido corresponde a referencias y una bibliografía. Puede agregar citas de cualquier trabajo almacenado en el archivo Bibtex Reference.bib que se encuentra en el directorio raíz de su libro. . Para incluir una cita en su libro, agregue una entrada bibtex a references.bib, por ejemplo: . @article{mayor1995jupiter, title={A Jupiter-mass companion to a solar-type star}, author={Mayor, Michel and Queloz, Didier}, journal={Nature}, volume={378}, number={6555}, pages={355--359}, year={1995}, publisher={Nature Publishing Group} } @article{guillot1999interiors, title={Interiors of giant planets inside and outside the solar system}, author={Guillot, Tristan}, journal={Science}, volume={286}, number={5437}, pages={72--77}, year={1999}, publisher={American Association for the Advancement of Science} } . Nota: Consulte la documentación de BibTex para obtener información sobre el estilo de referencia de BibTex. Google Scholar facilita la exportación de un formato de cita bibtex. . A continuación, puede hacer referencia al trabajo en su libro utilizando la siguiente directiva: . {cite}`mayor1995jupiter` . O para múltiples citas: . {cite}`mayor1995jupiter,guillot1999interiors` . Luego puede crear una bibliografía a partir de reference.bib usando: . {bibliography} references.bib . Por ejemplo, intente agregar esto a su archivo Introduction.md: . There might even be more planets out there with a similar mass to Jupiter {cite}`mayor1995jupiter,guillot1999interiors`! ## Bibliography {bibliography} references.bib . Su archivo final Introduction.md debería verse así: . # Jupiter Book This book contains information about the planet Jupiter - the fifth planet from the sun and the largest planet in the solar system! {numref}`jupiter-figure` below shows an image of Jupiter captured by the Hubble Space Telescope on June 27, 2019. {figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg height: 300px name: jupiter-figure The beautiful planet Jupiter! Source: [NASA](https://solarsystem.nasa.gov/resources/2486/hubbles-new-portrait-of-jupiter/?category=planets_jupiter). ## The Mass of Jupiter We can estimate the mass of Jupiter from the period and size of an object orbiting it. For example, we can use Jupiter&#39;s moon Callisto to estimate it&#39;s mass. Callisto&#39;s period: $p_{c}=16.7 days$ Callisto&#39;s orbit radius: $r_{c}=1,900,000 km$ Now, using [Kepler&#39;s Law](https://solarsystem.nasa.gov/resources/310/orbits-and-keplers-laws/) we can work out the mass of Jupiter. {math} :label: eq1 m_{j} approx frac{r_{c}}{p_{c}} times 7.9 times 10^{10} {math} :label: eq2 m_{j} approx 1.9 times 10^{27} kg {margin} Did you know? Jupiter is 11.0x larger than Earth! {hint} NASA provides a lot more information about the physical characteristics of Jupiter [here](https://solarsystem.nasa.gov/planets/jupiter/by-the-numbers/). There might even be more planets out there with a similar mass to Jupiter {cite}`mayor1995jupiter,guillot1999interiors`! ## Bibliography {bibliography} references.bib . Y debería renderizarse así: . . Agregar un archivo de contenido de Jupyter Notebook . Todos los flujos de trabajo de formato y estilo que vimos en markdown también se aplican a un Jupyter Notebook; simplemente agréguelos a una celda de markdown y listo. . Comencemos con lo siguiente: . Cree un nuevo notebook llamado great_red_spot.ipynb; | Agregue este archivo a su _toc.yml; | Agregue una celda de markdown con el siguiente contenido: | . # The Great Red Spot Jupiter’s iconic Great Red Spot (GRS) is actually an enormous storm that is bigger than Earth that has raged for hundreds of years! {numref}`great-red-spot` below shows an image of Jupiter captured by the Hubble Space Telescope on June 27, 2019. {figure} https://solarsystem.nasa.gov/system/resources/detail_files/626_PIA21775.jpg height: 300px name: great-red-spot Jupiter&#39;s Great Red Spot! Source: [NASA](https://solarsystem.nasa.gov/resources/626/jupiters-great-red-spot-in-true-color/?category=planets_jupiter). Jupiter&#39;s GRS has been observed to be shrinking for about the last century and a half! [Here](https://github.com/UBC-DSCI/jupyterdays/tree/master/jupyterdays/sessions/beuzen/data) is some data of the length of the GRS spanning the last ~150 years which we can use to investigate this phenomenon. . ¡Ahora intente construir su libro (jupyter-book build .) para asegurarse de que todo se vea bien! Usando la barra de contenido del lado izquierdo, navegue a la nueva página “The Great Red Spot”, que debería verse así: . . ¡Ok genial! Ahora importemos los datos a los que hicimos referencia para que podamos crear algunos gráficos. . Cree una nueva celda de código debajo de la celda de rebaja actual y agregue el siguiente código para leer en nuestro conjunto de datos de GRS como un marco de datos de Pandas. . import pandas as pd pd.options.plotting.backend = &quot;plotly&quot; url = &quot;https://raw.githubusercontent.com/UBC-DSCI/jupyterdays/master/jupyterdays/sessions/beuzen/data/GRS_data.csv&quot; df = pd.read_csv(url) df[&#39;Year&#39;] = df[&#39;Year&#39;].astype(int) df.head() . Nota:Estamos imprimiendo la salida en la pantalla con el uso de df.head() y esto se mostrará en nuestro Jupyter Book renderizado. Si reconstruye su libro (jupyter-book build .) en este punto, verá algo como lo siguiente: . . Ahora, podemos usar estos datos para crear algunos gráficos. . Las tramas en su Jupyter Book pueden ser estáticas (por ejemplo, matplotlib, seaborn) o interactivas (por ejemplo, altair, plotly, bokeh). Para este tutorial, crearemos algunos gráficos de ejemplo usando Plotly (a través del backend de Pandas). . Primero creemos un diagrama de dispersión simple de nuestros datos. Cree una nueva celda de código en su cuaderno y agregue el siguiente código: . import plotly.io as pio pio.renderers.default = &quot;notebook&quot; fig = df.plot.scatter(x=&quot;Year&quot;, y=&quot;GRS Length&quot;, color=&quot;Recorder&quot;, range_x=[1870, 2030], range_y=[10, 40], width=650, height=400) fig.update_layout(title={&#39;text&#39;: &quot;Great Red Spot Size&quot;, &#39;x&#39;:0.5, &#39;y&#39;:0.92}) fig.update_traces(marker=dict(size=7)) . Ya que estamos en eso, creemos también una trama animada. Cree otra celda de código nueva y agregue el siguiente código: . fig = df.plot.scatter(x=&quot;Year&quot;, y=&quot;GRS Length&quot;, animation_frame=&quot;Year&quot;, range_x=[1870, 2030], range_y=[10, 40], width=600, height=520) fig.update_layout(title={&#39;text&#39;: &quot;Great Red Spot Size Animation&quot;, &#39;x&#39;:0.5, &#39;y&#39;:0.94}) fig.layout.updatemenus[0].buttons[0].args[1][&quot;frame&quot;][&quot;duration&quot;] = 200 fig.update_traces(marker=dict(size=10)) . Nota: Plotly tiene diferentes renderizadores disponibles para generar gráficos. Es posible que deba experimentar con renderizadores para obtener el resultado que desea en su Jupyter Book. He descubierto que pio.renderers.default = &quot;notebook&quot; funciona con la versión actual de Jupyter Book. ¡Ahora, reconstruyamos nuestro libro y echemos un vistazo! . . Es posible que desee ocultar parte del código en su libro, ¡no hay problema! Eso también se hace fácilmente con Jupyter Book. . El que nos interesa aquí es ocultar la entrada de código. Podemos hacerlo fácilmente agregando la etiqueta hide-input a la celda que deseamos ocultar. Hay varias formas de agregar etiquetas a la celda en Jupyter Notebooks. En Jupyter Lab, haga clic en el icono de engranaje en la barra lateral izquierda y luego agregue la etiqueta deseada como se muestra a continuación: . . Continúe y agregue las etiquetas hide-input a ambas celdas de trazado en su archivo great_red_spot.ipynb. Cuando reconstruyas el libro, verás que la entrada del código está oculta (pero se puede alternar con el ícono +): . . Nota:También puede almacenar el contenido de la libreta como valores, gráficos o marcos de datos en variables que se pueden utilizar en toda su libreta mediante la herramienta glue. . Referencias . Jupyter-Book - Documentation | Tutorial - Jupyter Book | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/08/20/jb.html",
            "relUrl": "/jupyter/2021/08/20/jb.html",
            "date": " • Aug 20, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "RISE",
            "content": "Introducci&#243;n . RISE es una extensión a los jupyter notebooks que permite transformar tus notebooks en presentaciones interactivas. . Toda las celdas pueden editarse y ejecutarse directamente, durante la presentación. Esto es práctico si necesitas corregir un error en una celda de texto. Más importante aún, puedes ejecutar código directamente en el kernel. En una misma diapositiva puedes tener múltiples celdas y elegir cuál ejecutar, o corregir el texto y volver a ejecutar. . . Algunas características importantes del uso de RISE: . Simplifica la generación de material. | Se mantiene un archivo y no varios archivos para hablar de lo mismo. | Es fácil de corregir, no se necesita mucho esfuerzo (similar a una PPT). | . En esta sesión, se muestra un ejemplo de cómo crear una presentación con RISE. . Nota:Puede encontrar los códigos de este ejemplo en el siguiente repositorio. Por otro lado, puede revisar el siguente link para ver la compilación con GitLab CI/CD. . Primeros Pasos . Instalaci&#243;n . Para instalar RISE, necesitará usar la línea de comando. Si ha instalado Anaconda, puede usar: . conda install -c conda-forge rise . De lo contrario, puede instalar con pip: . pip install RISE . Nota:No interactuarás directamente con RISE. En su lugar, podrá acceder a él a través de Jupyter Notebooks. . Habilitaci&#243;n del modo de presentaci&#243;n . Para crear una presentación, deberá iniciar Jupyter Notebooks y abrir un nuevo notebook (tenga en cuenta que debe hacer esto después de haber instalado RISE). Una vez que tenga un Jupyter Notebook nuevo, deberá habilitar la presentación de diapositivas. Puede hacer esto haciendo lo siguiente: . Haga clic en &quot;Ver&quot; en la barra de herramientas de Jupyter | Coloca el cursor sobre &quot;Barra de herramientas de celda&quot; en el menú &quot;Ver&quot; | Haga clic en &quot;Presentación de diapositivas&quot; en el menú &quot;Barra de herramientas de celda&quot; | . . Creando las diapositivas con celdas . En este punto, debería tener una barra de herramientas de celda con un menú desplegable en el lado derecho: . Debería ver seis opciones aquí. Este menú desplegable y sus opciones determinan cómo encaja cada celda en la presentación. Las opciones y sus descripciones se encuentran a continuación: . slide: indica que la celda seleccionada debe ser el comienzo de una nueva diapositiva. | sub-slide -: indica que la celda seleccionada debe ser el comienzo de una nueva sub-diapositiva, que aparece en un nuevo marco debajo de la diapositiva anterior. | fragment: indica que la celda seleccionada debe aparecer como una compilación de la diapositiva anterior. | skip: indica que la celda seleccionada debe omitirse y no ser parte de la presentación de diapositivas. | notes: indica que la celda seleccionada debe ser solo notas del presentador. | - -: indica que la celda seleccionada debe seguir el comportamiento de la celda anterior, lo cual es útil cuando una celda de rebaja y una celda de código deben aparecer simultáneamente. | . Cada una de estas opciones puede incluir código Python o código Markdown/HTML/LaTeX como un Jupyter Notebook tradicional. . Ver la presentaci&#243;n de diapositivas . Una vez que se han utilizado las celdas para crear material para la presentación, la presentación se puede ver directamente desde el notebook. . Hay dos opciones para ver la presentación de diapositivas: . Usar el acceso directo OPTION + R shortcut (ALT + R on Windows) para ingresar y salir del modo de presentación desde dentro de la computadora portátil | Al hacer clic en el botón &quot;Modo de presentación&quot; de la computadora portátil, esto solo aparecerá si ha instalado RISE. | . . Después de ingresar al modo de presentación, debería ver una pantalla similar a esta: . . Cambio de diapositivas . Si bien puede ser tentador usar las teclas &lt;- y -&gt; para cambiar las diapositivas en la presentación, esto no funcionará por completo: omitirá las celdas marcadas como sub-slides. En su lugar, se debe usar ESPACIO para mover la presentación de diapositivas hacia adelante y MAYÚS + ESPACIO para mover la presentación de diapositivas hacia atrás. . Hay muchos otros atajos de teclado a los que se puede acceder dentro de la presentación haciendo clic en el signo de interrogación (?) en la esquina inferior izquierda. . Ejecuci&#243;n de c&#243;digo y edici&#243;n sobre la marcha . Una de las mejores cosas de RISE es que funciona en una sesión de Python en vivo, lo que significa que puede editar y ejecutar código mientras se ejecuta la presentación. . . Exportar presentaci&#243;n . Puedes exportar tu presentación desplegando la opción: File -&gt; Download as. . Nota:Para poder descargar en formato .pdf, necesita tener instalado pandoc. . . Referencias . RISE - Documentation | Creating Interactive Slideshows in Jupyter Notebooks | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/08/05/rise.html",
            "relUrl": "/jupyter/2021/08/05/rise.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "TDD",
            "content": "Introducci&#243;n . Esta página busca dar señales de cómo abordar el desarrollo de software para Data Science usando Test Driven Development, una técnica ampliamente usada en otros rubros de la programación. . &#191;Qu&#233; es el Test Driven Development? . En palabras simples, el desarrollo guiado por pruebas pone las pruebas en el corazón de nuestro trabajo. En su forma más simple consiste en un proceso iterativo de 3 fases: . . Red: Escribe un test que ponga a prueba una nueva funcionalidad y asegurate de que el test falla | Green: Escribe el código mínimo necesario para pasar ese test | Refactor: Refactoriza de ser necesario | . &#191;Porqu&#233; deber&#237;a usarlo? . Existen varias razones por las que uno debería usar TDD. Entre ellas podemos encontrar: . Formular bien nuestros pensamientos mediante la escritura de un test significativo antes de ponernos a solucionar el problema nos ayuda a clarificar los límites del problema y cómo podemos resolverlo. Con el tiempo esto ayuda a obtener un diseño modular y reusable del código. | Escribir tests ayuda la forma en que escribimos código, haciéndolo más legible a otros. Sin embargo, no es un acto de altruismo, la mayoría de las veces ese otro es tu futuro yo. | Verifica que el código funciona de la manera que se espera, y lo hace de forma automática. | Te permite realizar refactoring con la certeza de que no has roto nada. | Los tests escritos sirven como documentación para otros desarrolladores. | Es una práctica requerida en metodologías de desarrollo de software agile. | . Evidencia emp&#237;rica . El 2008, Nagappan, Maximilien, Bhat y Williams publicaron el paper llamado Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams, en donde estudiaron 4 equipos de trabajo (3 de Microsoft y 1 de IBM), con proyectos que variaban entre las 6000 lineas de código hasta las 155k. Estas son parte de sus conclusiones: . Todos los equipos demostraron una baja considerable en la densidad de defectos:40% para el equipo de IBM, y entre 60-90% para los equipos de Microsoft. . Como todo en la vida, nada es gratis: . Incremento del tiempo de desarrollo varía entre un 15% a 35%. . Sin embargo . Desde un punto de vista de eficacia este incremento en tiempo de desarrollo se compensa por los costos de mantención reducidos debido al incremento en calidad. . Además, es importante escribir tests junto con la implementación en pequeñas iteraciones. George y Williams encontraron que escribir tests después de que la aplicación está mas o menos lista hace que se testee menos porque los desarrolladores piensan en menos casos, y además la aplicación se vuelve menos testeable. Otra conclusión interesante del estudio de George y Williams es que un 79% de los desarrolladores experimentaron que el uso de TDD conlleva a un diseño más simple. . &#191;Puedo usar TDD siempre? . No, pero puedes usarlo casi siempre. El análisis exploratorio es un caso en que el uso de TDD no hace sentido. Una vez que tenemos definido el problema a solucionar y un mejor entendimiento del problema podemos aterrizar nuestras ideas a la implementación vía testing. . Librer&#237;as disponibles . Acá listamos algunas librerías de TDD de los lenguajes que se usan en i+D . Python . unittest: Módulo dentro de la librería estándar de Python. Permite realizar tests unitarios, de integración y end to end. | doctest: Permite realizar test de la documentación del código, cuando éste trae ejemplos de uso (Como en la documentacion de Numpy o Pandas). | pytest: Librería de testing ampliamente usada en proyectos nuevos de Python. | nose: Librería que extiende unittest para hacerlo más simple. | coverage: Herramienta para medir la cobertura de código de los proyectos. | tox: Herramienta para facilitar el test de una librería en diferentes versiones e intérpretes de Python. | hypothesis: Librería para escribir tests vía reglas que ayuda a encontrar casos borde. | behave: Permite utilizar Behavior Driven Development, un proceso de desarrollo derivado del TDD. | . Knowledge base / Lecturas recomendadas . Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams, es una buena lectura, sobretodo los consejos que dan en las conclusiones. | Google Testing Blog: Poseen varios artículos sobre cómo abordar problemas tipo, buenas prácticas de diseño para generar código testeable, entre otros. En particular destaca la serie Testing on the Toilet. | Cualquier artículo de Martin Fowler sobre testing, empezando por éste | Design Patterns: Los patrones de diseño de software tienen en consideración que el código sea testeable. | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/07/31/tdd.html",
            "relUrl": "/jupyter/2021/07/31/tdd.html",
            "date": " • Jul 31, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About me",
          "content": "Contact Information . . Name: Francisco Antonio Alfaro Medina | Phone: +56 9 94541139 | Email: francisco.alfaro.496@gmail.com | Curriculum Vitae: link | . Personal Information . 🎮 Gaming | 🏀 Basketball | 💡 Learning | 📚 Teaching . Statistician and Teacher at Universidad Técnica Federico Santa María. I currently work as a Senior Data Scientist at ITAU (Bank). I enjoy programming, learning about different topics and teaching about maths and computer. . 🔍 Interests: . Software Development | Statistical Modelling | Machine/Deep Learning | Cloud computing | Big Data | Time Series | . My Tech Stack . Languages &amp; Frameworks . . Cloud . . Tools and Others . . Certifications . | | | | | | .",
          "url": "https://fralfaro.github.io/ds_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Research & Talks",
          "content": "Research . Alfaro,F. (2019). Estimation of the reciprocal effects between Happiness and Job Performance in Chile. Master thesis. PDF. | Alfaro,F. (2018/2019). University retention about construction engineering students.Repository. | Alfaro,F. (2018). Spatial-statistics study for 3D Kriging (laboratory tests for tailings).Investigation. Repository. | Alfaro,F. (2017). Fraud detection in drinking water consumption.Degree thesis. PDF. | . Talks . Alfaro,F. (2018). Estimation of the reciprocal effects between Happiness and Job Performance in Chile. FNE33/CLATSE13 Congress. Guadalajara, MX, October 04, 2018. Talk, Validation. | .",
          "url": "https://fralfaro.github.io/ds_blog/research/",
          "relUrl": "/research/",
          "date": ""
      }
      
  

  
  

  
  

  
      ,"page6": {
          "title": "Software",
          "content": "Python Packages . Python is an interpreted high-level general-purpose programming language. Python is used for web development, AI, machine learning, operating systems, mobile application development, and video games. I contribute as developer/maintainer of the following Python packages: . fastmatrix: Fast computation of some matrices useful in statistics . . Yet another R package for matrices. It contains a small set of functions to fast computation of some matrices and operations useful in statistics. . HEAVY: Robust estimation using heavy-tailed distributions . . Functions to perform robust estimation considering heavy-tailed distributions. Currently, the package includes linear regression, linear mixed-effect models, multivariate location and scatter estimation, multivariate regression, penalized splines and random variate generation. . L1pack: Routines for L1 Estimation . . Provides routines to perform L1 estimation for linear regression, evaluation of density, distribution function, quantile function and random number generation for univariate and multivariate Laplace distribution. . MVT: Estimation and testing for the multivariate t-distribution . . This package contains a set of routines to perform estimation and inference under the multivariate t-distribution. These methods are a direct generalization of the multivariate inference under the gaussian assumption. In addition, these procedures provide robust methods useful against outliers. . SpatialPack: Tools for assessment the association between two spatial processes . . This package provides tools to assess the association between two spatial processes. Currently, four methodologies are implemented: A modified t-test to perform hypothesis testing about the independence between the processes, a suitable nonparametric correlation coefficient, the codispersion coefficient, and an F test for assessing the multiple correlation between one spatial process and several others. Functions for image processing and computing the spatial association between images are also provided. SpatialPack gives methods to complement methodologies that are available in geoR for one spatial process. .",
          "url": "https://fralfaro.github.io/ds_blog/software/",
          "relUrl": "/software/",
          "date": ""
      }
      
  

  
      ,"page7": {
          "title": "Teaching",
          "content": "Universities Courses . MAT281 - Applications of Mathematics in Engineering . University: Universidad Técnica Federico Santa María (UTFSM) | Course: Applications of Mathematics in Engineering | Course abbreviation: MAT281 | Prerequisites: None | Academic Unit that teaches it: Department of Mathematics | Training axis: Applied Engineering and Integration | Information: file | Repository: 2019, 2020, 2021 | . Previous Courses . MAT021 - Calculus and Algebra I (UTFSM) | MAT022 - Calculus and Algebra II (UTFSM) | . Personal Courses . Basic Tools . Course: Basic Tools | Description: Basic tools for Data Scientists | Repository: link | . Python Introduction . Course: Python Introduction | Description: Basic concepts about Python | Repository: link | . Data Structures and Algorithms . Course: Data Structures and Algorithms | Description: Data structures and algorithms with Python | Repository: link | . Data Manipulation . Course: Data Manipulation | Description: Basic concepts about data manipulation wih Python (Numpy, Panda, Matplotlib) | Repository: link | . Machine Learning . Course: Machine Learning | Description: Basic concepts about Machine Learning (numpy, pandas, scikit-learn) | Repository: link | . Deep Learning . Course: Deep Learning | Description: Basic concepts about Deep Learning with Tensorflow and Keras | Repository: link | . Big Data . Course: Big Data | Description: Basic concepts about Big Data with Pyspark | Repository: link | . Software Design I . Course: Software Design I | Description: Basic concepts about software design (version control, testing, and automatic build management) | Repository: link | . Software Design II . Course: Software Design II | Description: Advanced concepts about software design (version control, testing, and automatic build management) | Repository: link | .",
          "url": "https://fralfaro.github.io/ds_blog/teaching/",
          "relUrl": "/teaching/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fralfaro.github.io/ds_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}