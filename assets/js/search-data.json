{
  
    
        "post0": {
            "title": "Buenas Prácticas",
            "content": "Introducci&#243;n . Una pregunta que surgue a menudo cuando uno se encuentra programando es saber cuál es la forma correcta de programar. La respuesta es que no existe la forma correcta de programar (ya sea en Python o cualquier otro lenguaje), sin embargo, existen estandares dentro del mundo de la programación, con el fin de hacer el código más legible, sencillo de entender y ayudar a encontrar posibles errores. . En esta sección se mostrará algunos conceptos sencillos que te ayudarán a mejorar tus skills en el desarrollo de software (con Python). . Estilo de codificaci&#243;n: PEP8 . El PEP8 es un estilo de codificación que proporciona convenciones de codificación para el código Python que comprende la biblioteca estándar en la distribución principal de Python. . Algunos aspectos importantes: . El PEP8 y el PEP 257 (Docstring Conventions) fueron adaptados del ensayo original de la Guía de estilo Python de Guido, con algunas adiciones de la guía de estilo de Barry. . | Esta guía de estilo evoluciona con el tiempo a medida que se identifican convenciones adicionales y las convenciones pasadas se vuelven obsoletas debido a cambios en el propio lenguaje. . | Muchos proyectos tienen sus propias pautas de estilo de codificación. En caso de conflicto, dichas guías específicas del proyecto tienen prioridad para ese proyecto. . | . Basados en el PEP8 y algunas buenas prácticas del diseño de software, veamos ejemplo para poder escribir de mejor forma nuestros códigos. . Variables . Cuando sea posible, define variables con nombres que tengan algún sentido o que puedas identificar fácilmente, no importa que sean más largas. Por ejemplo, en un programa podríamos escribir: . a = 10. b = 3.5 print(f&quot;El area es {a*b}&quot; ) . El area es 35.0 . pero, ¿qué significan a y b? lo sabemos por el comentario (bien hecho), pero si más adelante nos encontramos con esas variables, tendremos que recordar cual es cual. Es mejor usar nombres con significado: . altura = 10. base = 3.5 print(f&quot;El area es {a*b}&quot; ) . El area es 35.0 . Lineas de c&#243;digos . Las líneas de codigo no deben ser muy largas, como mucho 72 caracteres. Si se tiene una línea larga, se puede cortar con una barra invertida ( ) y continuar en la siguiente línea: . print(&quot;Esta es una frase muy larga, se puede cortar con un y seguir en la línea inferior.&quot;) . Esta es una frase muy larga, se puede cortar con un y seguir en la línea inferior. . Comentarios . Los comentarios son muy importantes al escribir un programa. Describen lo que está sucediendo dentro de un programa, para que una persona que mira el código fuente no tenga dificultades para descifrarlo. . # esto es un comentario print(&#39;Hola&#39;) . Hola . También podemos tener comentarios multilíneas: . # Este es un comentario largo # y se extiende # a varias líneas . Importaciones . Las importaciones generalmente deben estar en líneas separadas: . # no: import sys, os . # si: import os import sys . Comparaciones . Existen varias formas de hacer comparaciones de objetos (principalmente en el uso del bucle if), acá se dejan alguna recomendaciones: . # no if greeting == True: # no if greeting is True: . # si if greeting: . Identaci&#243;n . Dentro de paréntesis, corchetes o llaves, no dejar espacios inmediatamente dentro de ellos: . # no lista_01 = [1, 2, 3,4, 5, 6,7, 8, 9,] . # si lista_01 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, ] . Aunque en Python se pueden hacer varias declaraciones en una línea, se recomienda hacer sólo una en cada línea: . # no a = 10; b = 20 . # si a = 10 b = 20 . Cuando se trabaja con lista, conjuntos y/o tuplas se recomienda poner en cada línea sus argumentos. . # no lista = [(1, &#39;hola&#39;),(2, &#39;mundo&#39;),] . # si lista = [ (1, &#39;hola&#39;), (2, &#39;mundo&#39;), ] . Lo anterior se puede extender para funciones con muchos argumentos . # no def funcion_01(x1,x2,x3,x4): print(x1,x2,x3,x4) def funcion_02( x1,x2,x3,x4): print(x1,x2,x3,x4) . # si def funcion_01(x1,x2, x3,x4): print(x1,x2,x3,x4) def funcion_02( x1,x2, x3,x4): print(x1,x2,x3,x4) . Operadores binarios . Un tema interesante es corresponde a la identación respecto a los operadores binarios, acá se muestra la forma correcta de hacerlo: . # no income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) . # si income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) . Manipulaci&#243;n de listas . Aunque combinar iterables con elementos de control de flujo para manipular listas es muy sencillo con Python, hay métodos específicos más eficientes para hacer lo mismo. Pensemos el fitrado de datos de una lista: . # Seleccionar los números positivos numeros = [-3, 2, 1, -8, -2, 7] positivos = [] for i in numeros: if i &gt; 0: positivos.append(i) print(f&quot;positivos: {positivos}&quot;) . positivos: [2, 1, 7] . Aunque técnicamente es correcto, es más eficiente hacer List Comprehension: . # comprension de lista numeros = [-3, 2, 1, -8, -2, 7] positivos = [i for i in numeros if i &gt; 0] # List Comprehension print(f&quot;positivos: {positivos}&quot;) . positivos: [2, 1, 7] . Especificar tipo de error . Cuando se ocupa try/except, es necesario especificar el tipo de error que se está cometiendo. . # importar librerias import sys . # no try: r = 1/0 except: print(&quot;Oops! ocurrio un&quot;,sys.exc_info()[0]) . Oops! ocurrio un &lt;class &#39;ZeroDivisionError&#39;&gt; . # si try: r = 1/0 except ZeroDivisionError: print(&quot;Oops! ocurrio un&quot;,sys.exc_info()[0]) . Oops! ocurrio un &lt;class &#39;ZeroDivisionError&#39;&gt; . Explicitar dependencias de una funci&#243;n . Siempre es mejor definir las variables dentro de una función y no dejar variables globales. . # no valor = 5 def funcion_01(variable): return 2*variable + valor . funcion_01(2) . 9 . # si def funcion_01(variable,valor): return 2*variable + valor . funcion_01(2,5) . 9 . Dynamic/Static typing . Con Python 3 se puede especificar el tipo de parámetro y el tipo de retorno de una función (usando la notación PEP484 y PEP526. Se definen dos conceptos claves: . Escritura dinámica: no se especifican los atributos de los inputs ni de los ouputs | Escritura estática: se especifican los atributos de los inputs y los ouputs | . # escritura dinámica def suma(x,y): return x+y . print(suma(1,2)) . 3 . # escritura estatica def suma(x:float, y:float)-&gt;float: return x+y . print(suma(1,2)) . 3 . Para la escritura estática, si bien se especifica el tipo de atributo (tanto de los inputs o outputs), la función puede recibir otros tipos de atributos. . print(suma(&quot;hola&quot;,&quot; mundo&quot;)) . hola mundo . Para validar los tipos de datos son los correctos, se deben ocupar librerías especializadas en la validación de datos (por ejemplo: pydantic). . Librer&#237;as . Existen librerías que pueden ayudar a corregir errores de escrituras en tú código (también conocido como Análisis Estático), por ejemplo: . black: El formateador de código inflexible. | flake8: La herramienta para aplicar la guía de estilo PEP8. | mypy: Mypy es un verificador de tipo estático para Python 3. | . Documentaci&#243;n . Casi tan importante como la escritura de código, es su correcta documentación, una parte fundamental de cualquier programa que a menudo se infravalora o simplemente se ignora. Aparte de los comentarios entre el código explicando cómo funciona, el elemento básico de documentación de Python es el Docstring o cadena de documentación, que ya hemos visto. Simplemente es una cadena de texto con triple comillas que se coloca justo después de la definición de función o clase que sirve de documentación a ese elemento. . def potencia(x, y): &quot;&quot;&quot; Calcula la potencia arbitraria de un numero &quot;&quot;&quot; return x**y . potencia.__doc__ . &#39; n Calcula la potencia arbitraria de un numero n &#39; . help(potencia) . Help on function potencia in module __main__: potencia(x, y) Calcula la potencia arbitraria de un numero . Lo correcto es detallar lo mejor posible en el Docstring qué hace y cómo se usa la función o clase y los parámetros que necesita. Se recomienda usar el estilo de documentación del software de documentación sphinx, que emplea reStructuredText como lenguaje de marcado. . Veamos un ejemplo de una función bien documentada: . def potencia(x, y): &quot;&quot;&quot; Calcula la potencia arbitraria de un numero :param x: base :param y: exponente :return: potencia de un numero :ejemplos: &gt;&gt;&gt; potencia(2, 1) 2 &gt;&gt;&gt; potencia(3, 2) 9 &quot;&quot;&quot; return x**y . potencia.__doc__ . &#39; n Calcula la potencia arbitraria de un numero n n :param x: base n :param y: exponente n :return: potencia de un numero n :ejemplos: n n &gt;&gt;&gt; potencia(2, 1) n 2 n &gt;&gt;&gt; potencia(3, 2) n 9 n &#39; . help(potencia) . Help on function potencia in module __main__: potencia(x, y) Calcula la potencia arbitraria de un numero :param x: base :param y: exponente :return: potencia de un numero :ejemplos: &gt;&gt;&gt; potencia(2, 1) 2 &gt;&gt;&gt; potencia(3, 2) 9 . Existen varias formas de documentar tus funciones, las principales encontradas en la literatura son: . Google docstrings: forma de documentación recomendada por Google.. | reStructured Text: estándar oficial de documentación de Python; No es apto para principiantes, pero tiene muchas funciones. | NumPy/SciPy docstrings: combinación de NumPy de reStructured y Google Docstrings. | . Zen de python . El Zen de Python te dará la guía para decidir sobre que hacer con tu código, no te dice como lo debes escribir, sino como debes pensar si estas programando en Python. . Principios importantes: . Explícito es mejor que implícito: Que no se asuma nada, asegúrate que las cosas sean. | Simple es mejor que complejo: Evita código complejo, código espagueti o que hace mas cosas para poder hacer una simple tarea. | Plano es mejor que anidado: Si tu código tiene mas de 3 niveles de identación, deberías mover parte de ese código a una función. | Los errores nunca deberían pasar silenciosamente: No uses un Try/Except sin definir que tipo de error vas a cachar, viene de la mano con Explicito es mejor que implícito. | Si la implementación es difícil de explicar, es mala idea. | . También, podemos ver el mensaje original del zen de python, ejecutando la siguiente linea de comando. . import this . The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&#39;s do more of those! . M&#225;s consejos . Los consejos que se presentan son de mucha utilidad si usted quiere llevar sus conociminetos de programación al siguiente nivel, sin embargo, el contenido de cada uno amerita un curso por si solo. Se deja recomienda al lector seguir profundizando en estos temas. . Entender programaci&#243;n multiparadigma . Python al ser multiparadigma, nos da una amplia gama de posibilidades de diseñar nuestros códigos. Dentro de estos se destacan: . Programación orientada a objetos (OOP) | Programación funcional | . Cuándo ocupar uno o la otra, va a depender de cómo queremos abordar una determinada problemática, puesto que en la mayoría de los casos, se puede pasar de un paradigma a o otro (incluso mezclarlos de ser necesario). . Principio S.O.L.I.D . En ingeniería de software, SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion) es un acrónimo mnemónico introducido por Robert C. Martin a comienzos de la década del 2000 que representa cinco principios básicos de la programación orientada a objetos y el diseño. Cuando estos principios se aplican en conjunto es más probable que un desarrollador cree un sistema que sea fácil de mantener y ampliar con el tiempo. . En el siguiente link se deja una guía para poder entender estos conceptos en python. . Patrones de dise&#241;o . Los patrones de diseño son la base para la búsqueda de soluciones a problemas comunes en el desarrollo de software y otros ámbitos referentes al diseño de interacción o interfaces. . Un patrón de diseño es una solución a un problema de diseño. . Se destacan tres tipos de patrones de diseños: . Comportamiento | Creacionales | Estructurales | . En el siguiente link se deja una guía para poder entender estos conceptos en python. . Lecturas recomendadas . The Clean Coder: A Code Of Conduct For Professional Programmers Robert C. Martin (2011) | Clean Code: A Handbook of Agile Software - Robert C. Martin (2009). | Working effectively with legacy code Michael C. Feathers (2004) | Refactoring Martin Fowler (1999) | The Pragmatic Programmer Thomas Hunt (1999) | .",
            "url": "https://fralfaro.github.io/ds_blog/pep8/documentation/tdd/2021/08/31/buenas_practicas.html",
            "relUrl": "/pep8/documentation/tdd/2021/08/31/buenas_practicas.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages",
            "content": "Introducci&#243;n . Fastpages es una plataforma que te permite crear y alojar un blog de forma gratuita, sin anuncios y con muchas funciones útiles, como: . Cree publicaciones que contengan código, salidas de código (que pueden ser interactivas), texto formateado, etc. directamente desde Jupyter Notebooks. Las publicaciones en notebooks admiten funciones como: Las visualizaciones interactivas realizadas con Altair siguen siendo interactivas. | Ocultar o mostrar la entrada y salida de la celda. | Celdas de código contraíbles que están abiertas o cerradas de forma predeterminada. | Defina el título, el resumen y otros metadatos a través de celdas de rebajas especiales | Posibilidad de agregar enlaces a Colab y GitHub automáticamente. | . | Cree publicaciones, incluido el formato y las imágenes, directamente desde documentos de Microsoft Word. | Cree y edite publicaciones de Markdown completamente en línea usando el editor de Markdown incorporado de GitHub. | Inserta tarjetas de Twitter y videos de YouTube. | Categorización de publicaciones de blog por etiquetas proporcionadas por el usuario para mayor visibilidad. | . En esta sección se enseñará los pasos básicos para poder crear su propio blog con fastpages. . Primeros pasos . Configurando Fastpages . ¡El proceso de configuración de páginas rápidas también está automatizado con GitHub Actions! Al crear un repositorio a partir de la plantilla de páginas rápidas, se abrirá automáticamente una solicitud de extracción (después de ~ 30 segundos) configurando su blog para que pueda comenzar a funcionar. La solicitud de extracción automatizada lo recibirá con instrucciones como esta: . ¡Todo lo que tienes que hacer es seguir estas instrucciones (en el PR que recibes) y tu nuevo sitio de blogs estará en funcionamiento! . Note: Si tienes dudas con la instalación, te recomiendo ver el siguiente video. . Estructura de Fastpages . El repositorio de fastpages esta compuesto de la siguiente forma: . ├── .github ├── _action_files ├── _fastpages_docs ├── images ├── _includes ├── _layouts ├── _notebooks ├── _pages ├── _plugins ├── _posts ├── _sass └── _word └── .devcontainer.json └── Makefile └── index.html └── Gemfile └── _config.yml └── LICENSE └── docker-compose.yml └── Gemfile.lock └── README.md └── .gitattributes └── .gitignore . De momento nos vamos a centrar en algunos de estos archivos: . _config.yml: es el archivo que funciona como el motor del proyecto. En ente archivo, podemos poner el nombre a nuestro blog, el logo, información personal (github, linkedin, etc), entre otras cosas. . | index.html: Corresponde a la primera página cuando se despliega nuestro blog. por lo que es importante escribir algún mensaje para especificar la motivación de hacer un blog. . | /_notebooks: Lugar donde se deben guardar los notebooks (.ipynb) con la convención de nomenclatura YYYY-MM-DD-*.ipynb. . | /_posts: Lugar donde se deben guardar los archivos markdown (.md) con la convención de nomenclatura YYYY-MM-DD-*.md. . | /_word: Lugar donde se deben guardar los archivos word (.docx) con la convención de nomenclatura YYYY-MM-DD-*.docx. . | . . Note: fastpages usa nbdev para impulsar el proceso de conversión de Jupyter Notebooks en publicaciones de blog. Cuando guardas un notebook en la carpeta /_notebooks de tu repositorio, GitHub Actions aplica nbdev a esos notebooks automáticamente. El mismo proceso ocurre cuando guarda documentos de Word o markdown en el directorio _word o_posts, respectivamente. . Jupyter Notebooks y Fastpages . En esta parte, se muestran características especiales que fastpages proporciona para los notebooks. También puede escribir las publicaciones de su blog con documentos de Word o makdown. . Opciones a trav&#233;s de FrontMatter . La primera celda de su Jupyter Notebook o markdown contiene información preliminar. El tema principal son los metadatos que pueden activar/desactivar opciones en su Notebook. Tiene el formato siguiente: . # Title &gt; Awesome summary - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Todas las configuraciones anteriores están habilitadas en esta publicación, ¡para que pueda ver cómo se ven! . El campo de resumen (precedido por &gt;) se mostrará debajo de su título y también lo utilizarán las redes sociales para mostrar la descripción de su página. | toc: establecer esto en true generará automáticamente una tabla de contenido | badges: establecer esto en true mostrará los enlaces de Google Colab y GitHub en la publicación de su blog. | comments: establecer esto en true habilitará los comentarios. Consulte estas instrucciones para obtener más detalles. | autor: esto mostrará los nombres de los autores. | categories: permitirá que su publicación sea categorizada en una página de &quot;Etiquetas&quot;, donde los lectores pueden navegar por su publicación por categorías. | . Markdown Front Matters tiene un formato similar al de los notebooks. Las diferencias entre los dos se puede ver en el siguiente link. . Code Folding . coloque una marca # collapse-hide en la parte superior de cualquier celda si desea ocultar esa celda de forma predeterminada, pero déle al lector la opción de mostrarla: . import pandas as pd import altair as alt . . coloque una marca # collapse-show en la parte superior de cualquier celda si desea mostrar esa celda de forma predeterminada, pero déle al lector la opción de ocultarla: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Si desea ocultar las celdas por completo (no solo contraerlas), lea estas instrucciones. . Tablas de datos . Puede mostrar tablas de la forma habitual en su blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;IMDB_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget IMDB_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | 6.1 | . 1 First Love, Last Rites | 10876.0 | 300000.0 | 6.9 | . 2 I Married a Strange Person | 203134.0 | 250000.0 | 6.8 | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | NaN | . 4 Slam | 1087521.0 | 1000000.0 | 3.4 | . Gr&#225;ficos interactivos con Altair . ¡Las visualizaciones interactivas realizadas con Altair siguen siendo interactivas! . Dejamos esta celda de abajo sin ocultar para que pueda disfrutar de una vista previa del resaltado de sintaxis en páginas rápidas, que utiliza el tema de drácula. . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . . Otras caracter&#237;sticas . Al escribir Le doy a esta publicación dos :+1:! Se mostrará esto: . Le doy a esta publicación dos :+1:! . Im&#225;genes con leyenda . Puede incluir imágenes de rebajas con leyenda (caption) como este: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Por supuesto, la leyenda es opcional. . Tweetcards . Si escribe &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 mostrará esto: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Si escribe &gt; youtube: https://youtu.be/XfoYk_Z5AkI mostrará esto: . Boxes/Callouts . Puedes ejecutar algunas cajas con mensajes de nota, información o warning!. A continuación se muestran algunos ejemplos: . &gt; Warning: There will be no second warning! . Warning: There will be no second warning! . &gt; Important: Pay attention! It&#39;s important. . Important: Pay attention! It&#8217;s important. . &gt; Tip: This is my tip. . Tip: This is my tip. . &gt; Note: Take note of this. . Note: Take note of this. . Referencias . Repositorio: fastpages | nbdev: notebooks a posts | Fastai: foro | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/08/20/fastpages.html",
            "relUrl": "/jupyter/2021/08/20/fastpages.html",
            "date": " • Aug 20, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Jupyter Book",
            "content": "Introducci&#243;n . Jupyter Book es un proyecto de código abierto para crear libros y documentos mediante Jupyter Notebooks y/o Markdown. . Algunas características importantes del uso de Jupyter Book: . contenido con calidad de publicación que incluya figuras, símbolos matemáticos, citas y referencias cruzadas! | escribir contenido como Jupyter Notebooks, markdown o reStructuredText | Agregue interactividad a su libro, por ejemplo, alternar la visibilidad de las celdas, conectarse con un servicio en línea como Binder e incluir resultados interactivos (por ejemplo, figuras y widgets). | generar una variedad de resultados, incluidos sitios web (HTML, CSS, JS), markdown y PDF. | una interfaz de línea de comandos para crear libros rápidamente, por ejemplo, jupyter-book build mybook | . En esta sesión, se muestra un ejemplo de cómo crear un Jupyter Book desde cero y algunas de las características clave que ofrece Jupyter Book. . Nota:Puede encontrar los códigos de este ejemplo en el siguiente repositorio. Por otro lado, puede revisar el siguente link para ver la compilación con GitLab CI/CD. . Primeros pasos . Instalaci&#243;n . Para instalar Jupyter Book, necesitará usar la línea de comando. Si ha instalado Anaconda, puede usar: . conda install -c conda-forge jupyter-book . De lo contrario, puede instalar con pip: . pip install jupyter-book . Crear una estructura de libro . Jupyter Book viene con una herramienta que le permite crear y construir libros rápidamente. Para crear el esqueleto del libro, escriba lo siguiente en la línea de comando: . jupyter-book create jupiter . Nota:Aquí llamamos al libro jupiter, pero puedes elegir llamar a tu libro como quieras. . Ahora tendrás un nuevo directorio llamado jupiter (o como quieras llamar a tu libro), con el siguiente contenido: . jupiter ├── _config.yml ├── _toc.yml ├── content.md ├── intro.md ├── markdown.md ├── notebooks.ipynb ├── references.bib └── requirements.txt . en donde: . _config.yml: archivo que contiene las configuraciones del proyecto. | _toc.yml: archivo que ordena los capítulos del libro. | content.md: archivo genérico .md. | intro.md: archivo genérico .md. | markdown.md: archivo genérico .md. | notebooks.ipynb: archivo genérico .ipynb. | references.bib: archivo para añadir las referencias. | requirements.txt: archivo que contiene las dependencias python) del proyecto. | . Re-estructuraci&#243;n del directorio . Jupyter Book admite varios tipos de archivos: . Markdown (.md) | notebooks (.ipynb) | etc. | . Como Markdown y Jupyter Notebooks probablemente serán los tipos de archivo más comunes que usará, se mostrará un ejemplo de ello. . Lo primero será eliminar los archivos de inicio en el directorio: . content.md | intro.md | markdown.md | notebooks.ipynb | . Así que ejecutamos por línea de comando: . rm content.md intro.md markdown.md notebooks.ipynb . Por otro lado, nuestro proyecto estaré conformado por tres archivos: . index.md | Introduction.md | great_red_spot.ipynb | . Luego, debemos indicar cómo serán mostrados estos documentos en el archivo _toc.yml. La estructura será la siguiente: . format: jb-book root: index chapters: - file: Introduction - file: great_red_spot . En este caso, root: index corresponde al primer archivo que se visualiza en el jupyter-book. Dentro del archivo index.md escribiremos: . # Home jupyter book example ## Contenidos {tableofcontents} . Agregar un archivo Markdown . Se comienza por agregar un archivo de markdown. Con algún editor a elección (por ejemplo, jupyter notebook o jupyterlab) se crea un nuevo archivo markdown llamado Introduction.md. . Se usa este archivo como demostración de algunos de los principales tipos de contenido que puede agregar en Jupyter-Book. . Texto . Se agrega un texto de Markdown simple a nuestro archivo. Si no está familiarizado con la sintaxis de markdown, consulte Markdown Cheat Sheet. Puede copiar y pegar el siguiente contenido directamente en su archivo Introduction.md. . # Jupiter Book This book contains information about the planet **Jupiter** - the fifth planet from the sun and the largest planet in the solar system! . Figuras . Puedes incluir figuras en tu Jupyter Book usando la siguiente sintaxis: . {figure} my_image.png height: 150px name: my-image Here is my image&#39;s caption! . Si bien la imagen puede estar contenida y referenciada desde el directorio raíz, también se puede incluir imágenes a través de URL. Incluyamos una imagen del planeta Júpiter en nuestro archivo Introduction.md usando lo siguiente: . {figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg height: 300px name: jupiter-figure The beautiful planet Jupiter! . La razón por la que le damos un &quot;nombre&quot; a nuestra imagen es para que podamos hacer referencia a ella fácilmente con la sintaxis: . {numref}`jupiter-figure` . Se agregará una oración que incluya esta referencia. El archivo completo ahora debería verse así: . # Jupiter Book This book contains information about the planet Jupiter - the fifth planet from the sun and the largest planet in the solar system! {numref}`jupiter-figure` below shows an image of Jupiter captured by the Hubble Space Telescope on June 27, 2019. {figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg height: 300px name: jupiter-figure The beautiful planet Jupiter! Source: [NASA](https://solarsystem.nasa.gov/resources/2486/hubbles-new-portrait-of-jupiter/?category=planets_jupiter). . En este punto, probablemente se debería crear nuetro libro para asegurarnos de que tenga el aspecto esperado. Para hacer eso, primero necesitamos modificar nuestro archivo _toc.yml. Este archivo contiene la tabla de contenido de nuestro libro. Abra ese archivo ahora y elimine todo lo que hay allí. Luego, simplemente agregue lo siguiente: . - file: introduction . Ahora podemos construir nuestro libro desde la línea de comandos asegurándonos de que estamos en el directorio raíz de nuestro libro y luego usando: . jupyter-book build . . Una vez finalizada la compilación, tendrá un nuevo subdirectorio llamado_build/html/ en la raíz de su libro, navegue hasta esa ubicación y abra _build/html/index.html. Debería verse algo como esto: . . Equaciones matem&#225;ticas . Jupyter Book usa MathJax para componer matemáticas, lo que le permite agregar matemáticas de estilo LaTeX a su libro. Puede agregar matemáticas en línea, bloques matemáticos y ecuaciones numeradas a su libro Jupyter. Sigamos adelante y creemos un nuevo encabezado en nuestro archivo Introduction.md que incluye algunas matemáticas. . Las matemáticas en línea se pueden definir usando $ de la siguiente manera: . Jupiter has a mass of: $m_{j} approx 1.9 times 10^{27} kg$ . Jupiter has a mass of: $m_{j} approx 1.9 times 10^{27} kg$ . Los bloques matemáticos se pueden definir usando la notación $$: . $$m_{j} approx 1.9 times 10^{27} kg$$ . $$m_{j} approx 1.9 times 10^{27} kg$$ . Nota:Si lo prefiere, los bloques matemáticos también se pueden definir con begin{equation} en lugar de $$. Las ecuaciones numeradas se pueden definir así (este es el estilo que te recomiendo que uses con más frecuencia): . {math} :label: my_label m_{j} approx 1.9 times 10^{27} kg . Agreguemos más contenido a nuestro libro. Copie y agregue el siguiente texto a su archivo Introduction.md: . ## The Mass of Jupiter We can estimate the mass of Jupiter from the period and size of an object orbiting it. For example, we can use Jupiter&#39;s moon Callisto to estimate it&#39;s mass. Callisto&#39;s period: $p_{c}=16.7 days$ Callisto&#39;s orbit radius: $r_{c}=1,900,000 km$ Now, using [Kepler&#39;s Law](https://solarsystem.nasa.gov/resources/310/orbits-and-keplers-laws/) we can work out the mass of Jupiter. {math} :label: eq1 m_{j} approx frac{r_{c}}{p_{c}} times 7.9 times 10^{10} {math} :label: eq2 m_{j} approx 1.9 times 10^{27} kg . A continuación, puede reconstruir su libro (jupyter-book build .) y abrir _build/html/index.html para asegurarse de que todo se esté procesando como se esperaba. . Controlando el dise&#241;o de la p&#225;gina . Hay varias formas diferentes de controlar el diseño de las páginas de su Jupyter Book. El cambio de diseño que utilizo con más frecuencia es agregar contenido a un margen en la página. Puede agregar un margen usando la siguiente directiva: . {margin} An optional title Some margin content. . Agreguemos algo de contenido marginal al libro: . {margin} Did you know? Jupiter is 11.0x larger than Earth! . Advertencias . Hay todo tipo de advertencias diferentes que puede usar en Jupyter Book que se enumeran aquí en la documentación de Jupyter Book. Las advertencias se crean con la sintaxis: . {note} I am a useful note! . No dude en agregar la siguiente advertencia a Introduction.md: . {hint} NASA provides a lot more information about the physical characteristics of Jupiter [here](https://solarsystem.nasa.gov/planets/jupiter/by-the-numbers/). . Citas y bibliograf&#237;a . El último contenido corresponde a referencias y una bibliografía. Puede agregar citas de cualquier trabajo almacenado en el archivo Bibtex Reference.bib que se encuentra en el directorio raíz de su libro. . Para incluir una cita en su libro, agregue una entrada bibtex a references.bib, por ejemplo: . @article{mayor1995jupiter, title={A Jupiter-mass companion to a solar-type star}, author={Mayor, Michel and Queloz, Didier}, journal={Nature}, volume={378}, number={6555}, pages={355--359}, year={1995}, publisher={Nature Publishing Group} } @article{guillot1999interiors, title={Interiors of giant planets inside and outside the solar system}, author={Guillot, Tristan}, journal={Science}, volume={286}, number={5437}, pages={72--77}, year={1999}, publisher={American Association for the Advancement of Science} } . Nota: Consulte la documentación de BibTex para obtener información sobre el estilo de referencia de BibTex. Google Scholar facilita la exportación de un formato de cita bibtex. . A continuación, puede hacer referencia al trabajo en su libro utilizando la siguiente directiva: . {cite}`mayor1995jupiter` . O para múltiples citas: . {cite}`mayor1995jupiter,guillot1999interiors` . Luego puede crear una bibliografía a partir de reference.bib usando: . {bibliography} references.bib . Por ejemplo, intente agregar esto a su archivo Introduction.md: . There might even be more planets out there with a similar mass to Jupiter {cite}`mayor1995jupiter,guillot1999interiors`! ## Bibliography {bibliography} references.bib . Su archivo final Introduction.md debería verse así: . # Jupiter Book This book contains information about the planet Jupiter - the fifth planet from the sun and the largest planet in the solar system! {numref}`jupiter-figure` below shows an image of Jupiter captured by the Hubble Space Telescope on June 27, 2019. {figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg height: 300px name: jupiter-figure The beautiful planet Jupiter! Source: [NASA](https://solarsystem.nasa.gov/resources/2486/hubbles-new-portrait-of-jupiter/?category=planets_jupiter). ## The Mass of Jupiter We can estimate the mass of Jupiter from the period and size of an object orbiting it. For example, we can use Jupiter&#39;s moon Callisto to estimate it&#39;s mass. Callisto&#39;s period: $p_{c}=16.7 days$ Callisto&#39;s orbit radius: $r_{c}=1,900,000 km$ Now, using [Kepler&#39;s Law](https://solarsystem.nasa.gov/resources/310/orbits-and-keplers-laws/) we can work out the mass of Jupiter. {math} :label: eq1 m_{j} approx frac{r_{c}}{p_{c}} times 7.9 times 10^{10} {math} :label: eq2 m_{j} approx 1.9 times 10^{27} kg {margin} Did you know? Jupiter is 11.0x larger than Earth! {hint} NASA provides a lot more information about the physical characteristics of Jupiter [here](https://solarsystem.nasa.gov/planets/jupiter/by-the-numbers/). There might even be more planets out there with a similar mass to Jupiter {cite}`mayor1995jupiter,guillot1999interiors`! ## Bibliography {bibliography} references.bib . Y debería renderizarse así: . Agregar un archivo de contenido de Jupyter Notebook . Todos los flujos de trabajo de formato y estilo que vimos en markdown también se aplican a un Jupyter Notebook; simplemente agréguelos a una celda de markdown y listo. . Comencemos con lo siguiente: . Cree un nuevo notebook llamado great_red_spot.ipynb; | Agregue este archivo a su _toc.yml; | Agregue una celda de markdown con el siguiente contenido: | . # The Great Red Spot Jupiter’s iconic Great Red Spot (GRS) is actually an enormous storm that is bigger than Earth that has raged for hundreds of years! {numref}`great-red-spot` below shows an image of Jupiter captured by the Hubble Space Telescope on June 27, 2019. {figure} https://solarsystem.nasa.gov/system/resources/detail_files/626_PIA21775.jpg height: 300px name: great-red-spot Jupiter&#39;s Great Red Spot! Source: [NASA](https://solarsystem.nasa.gov/resources/626/jupiters-great-red-spot-in-true-color/?category=planets_jupiter). Jupiter&#39;s GRS has been observed to be shrinking for about the last century and a half! [Here](https://github.com/UBC-DSCI/jupyterdays/tree/master/jupyterdays/sessions/beuzen/data) is some data of the length of the GRS spanning the last ~150 years which we can use to investigate this phenomenon. . ¡Ahora intente construir su libro (jupyter-book build .) para asegurarse de que todo se vea bien! Usando la barra de contenido del lado izquierdo, navegue a la nueva página “The Great Red Spot”, que debería verse así: . . ¡Ok genial! Ahora importemos los datos a los que hicimos referencia para que podamos crear algunos gráficos. . Cree una nueva celda de código debajo de la celda de rebaja actual y agregue el siguiente código para leer en nuestro conjunto de datos de GRS como un marco de datos de Pandas. . import pandas as pd pd.options.plotting.backend = &quot;plotly&quot; url = &quot;https://raw.githubusercontent.com/UBC-DSCI/jupyterdays/master/jupyterdays/sessions/beuzen/data/GRS_data.csv&quot; df = pd.read_csv(url) df[&#39;Year&#39;] = df[&#39;Year&#39;].astype(int) df.head() . Nota:Estamos imprimiendo la salida en la pantalla con el uso de df.head() y esto se mostrará en nuestro Jupyter Book renderizado. Si reconstruye su libro (jupyter-book build .) en este punto, verá algo como lo siguiente: . . Ahora, podemos usar estos datos para crear algunos gráficos. . Las tramas en su Jupyter Book pueden ser estáticas (por ejemplo, matplotlib, seaborn) o interactivas (por ejemplo, altair, plotly, bokeh). Para este tutorial, crearemos algunos gráficos de ejemplo usando Plotly (a través del backend de Pandas). . Primero creemos un diagrama de dispersión simple de nuestros datos. Cree una nueva celda de código en su cuaderno y agregue el siguiente código: . import plotly.io as pio pio.renderers.default = &quot;notebook&quot; fig = df.plot.scatter(x=&quot;Year&quot;, y=&quot;GRS Length&quot;, color=&quot;Recorder&quot;, range_x=[1870, 2030], range_y=[10, 40], width=650, height=400) fig.update_layout(title={&#39;text&#39;: &quot;Great Red Spot Size&quot;, &#39;x&#39;:0.5, &#39;y&#39;:0.92}) fig.update_traces(marker=dict(size=7)) . Ya que estamos en eso, creemos también una trama animada. Cree otra celda de código nueva y agregue el siguiente código: . fig = df.plot.scatter(x=&quot;Year&quot;, y=&quot;GRS Length&quot;, animation_frame=&quot;Year&quot;, range_x=[1870, 2030], range_y=[10, 40], width=600, height=520) fig.update_layout(title={&#39;text&#39;: &quot;Great Red Spot Size Animation&quot;, &#39;x&#39;:0.5, &#39;y&#39;:0.94}) fig.layout.updatemenus[0].buttons[0].args[1][&quot;frame&quot;][&quot;duration&quot;] = 200 fig.update_traces(marker=dict(size=10)) . Nota: Plotly tiene diferentes renderizadores disponibles para generar gráficos. Es posible que deba experimentar con renderizadores para obtener el resultado que desea en su Jupyter Book. He descubierto que pio.renderers.default = &quot;notebook&quot; funciona con la versión actual de Jupyter Book. ¡Ahora, reconstruyamos nuestro libro y echemos un vistazo! . . Es posible que desee ocultar parte del código en su libro, ¡no hay problema! Eso también se hace fácilmente con Jupyter Book. . El que nos interesa aquí es ocultar la entrada de código. Podemos hacerlo fácilmente agregando la etiqueta hide-input a la celda que deseamos ocultar. Hay varias formas de agregar etiquetas a la celda en Jupyter Notebooks. En Jupyter Lab, haga clic en el icono de engranaje en la barra lateral izquierda y luego agregue la etiqueta deseada como se muestra a continuación: . . Continúe y agregue las etiquetas hide-input a ambas celdas de trazado en su archivo great_red_spot.ipynb. Cuando reconstruyas el libro, verás que la entrada del código está oculta (pero se puede alternar con el ícono +): . . Nota:También puede almacenar el contenido de la libreta como valores, gráficos o marcos de datos en variables que se pueden utilizar en toda su libreta mediante la herramienta glue. . Referencias . Jupyter-Book - Documentation | Tutorial - Jupyter Book | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/08/11/jb.html",
            "relUrl": "/jupyter/2021/08/11/jb.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "RISE",
            "content": "Introducci&#243;n . RISE es una extensión a los jupyter notebooks que permite transformar tus notebooks en presentaciones interactivas. . Toda las celdas pueden editarse y ejecutarse directamente, durante la presentación. Esto es práctico si necesitas corregir un error en una celda de texto. Más importante aún, puedes ejecutar código directamente en el kernel. En una misma diapositiva puedes tener múltiples celdas y elegir cuál ejecutar, o corregir el texto y volver a ejecutar. . . Algunas características importantes del uso de RISE: . Simplifica la generación de material. | Se mantiene un archivo y no varios archivos para hablar de lo mismo. | Es fácil de corregir, no se necesita mucho esfuerzo (similar a una PPT). | . En esta sesión, se muestra un ejemplo de cómo crear una presentación con RISE. . Nota:Puede encontrar los códigos de este ejemplo en el siguiente repositorio. Por otro lado, puede revisar el siguente link para ver la compilación con GitLab CI/CD. . Primeros Pasos . Instalaci&#243;n . Para instalar RISE, necesitará usar la línea de comando. Si ha instalado Anaconda, puede usar: . conda install -c conda-forge rise . De lo contrario, puede instalar con pip: . pip install RISE . Nota:No interactuarás directamente con RISE. En su lugar, podrá acceder a él a través de Jupyter Notebooks. . Habilitaci&#243;n del modo de presentaci&#243;n . Para crear una presentación, deberá iniciar Jupyter Notebooks y abrir un nuevo notebook (tenga en cuenta que debe hacer esto después de haber instalado RISE). Una vez que tenga un Jupyter Notebook nuevo, deberá habilitar la presentación de diapositivas. Puede hacer esto haciendo lo siguiente: . Haga clic en &quot;Ver&quot; en la barra de herramientas de Jupyter | Coloca el cursor sobre &quot;Barra de herramientas de celda&quot; en el menú &quot;Ver&quot; | Haga clic en &quot;Presentación de diapositivas&quot; en el menú &quot;Barra de herramientas de celda&quot; | . . Creando las diapositivas con celdas . En este punto, debería tener una barra de herramientas de celda con un menú desplegable en el lado derecho: . Debería ver seis opciones aquí. Este menú desplegable y sus opciones determinan cómo encaja cada celda en la presentación. Las opciones y sus descripciones se encuentran a continuación: . slide: indica que la celda seleccionada debe ser el comienzo de una nueva diapositiva. | sub-slide -: indica que la celda seleccionada debe ser el comienzo de una nueva sub-diapositiva, que aparece en un nuevo marco debajo de la diapositiva anterior. | fragment: indica que la celda seleccionada debe aparecer como una compilación de la diapositiva anterior. | skip: indica que la celda seleccionada debe omitirse y no ser parte de la presentación de diapositivas. | notes: indica que la celda seleccionada debe ser solo notas del presentador. | - -: indica que la celda seleccionada debe seguir el comportamiento de la celda anterior, lo cual es útil cuando una celda de rebaja y una celda de código deben aparecer simultáneamente. | . Cada una de estas opciones puede incluir código Python o código Markdown/HTML/LaTeX como un Jupyter Notebook tradicional. . Ver la presentaci&#243;n de diapositivas . Una vez que se han utilizado las celdas para crear material para la presentación, la presentación se puede ver directamente desde el notebook. . Hay dos opciones para ver la presentación de diapositivas: . Usar el acceso directo OPTION + R shortcut (ALT + R on Windows) para ingresar y salir del modo de presentación desde dentro de la computadora portátil | Al hacer clic en el botón &quot;Modo de presentación&quot; de la computadora portátil, esto solo aparecerá si ha instalado RISE. | . . Después de ingresar al modo de presentación, debería ver una pantalla similar a esta: . . Cambio de diapositivas . Si bien puede ser tentador usar las teclas &lt;- y -&gt; para cambiar las diapositivas en la presentación, esto no funcionará por completo: omitirá las celdas marcadas como sub-slides. En su lugar, se debe usar ESPACIO para mover la presentación de diapositivas hacia adelante y MAYÚS + ESPACIO para mover la presentación de diapositivas hacia atrás. . Hay muchos otros atajos de teclado a los que se puede acceder dentro de la presentación haciendo clic en el signo de interrogación (?) en la esquina inferior izquierda. . Ejecuci&#243;n de c&#243;digo y edici&#243;n sobre la marcha . Una de las mejores cosas de RISE es que funciona en una sesión de Python en vivo, lo que significa que puede editar y ejecutar código mientras se ejecuta la presentación. . . Exportar presentaci&#243;n . Puedes exportar tu presentación desplegando la opción: File -&gt; Download as. . Nota:Para poder descargar en formato .pdf, necesita tener instalado pandoc. . . Referencias . RISE - Documentation | Creating Interactive Slideshows in Jupyter Notebooks | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/08/05/rise.html",
            "relUrl": "/jupyter/2021/08/05/rise.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Jupyter Noteboook",
            "content": "Introducci&#243;n . Jupyter Notebook, es un entorno de trabajo interactivo que permite desarrollar código en Python (por defecto, aunque permite otros lenguajes) de manera dinámica, a la vez que integrar en un mismo documento tanto bloques de código como texto, gráficas o imágenes. Es un SaaS utilizado ampliamente en análisis numérico, estadística y machine learning, entre otros campos de la informática y las matemáticas. . Por otro lado, JupyterLab es similar a Jupyter Notebook en cuanto a sus funcionalidade, pero tiene un interfaz más interesante para los usuarios. Eventualmente Jupyter Lab reemplazará a Jupyter Notebok. . Nos centraremos en comprender aspectos básicos de cómo trabajar un archivo en jupyter notebook (extensión .ipynb). . Primeros Pasos . Instalaci&#243;n . Para instalar RISE, necesitará usar la línea de comando. Si ha instalado Anaconda, puede usar: . conda install -c conda-forge notebook . De lo contrario, puede instalar con pip: . pip install notebook . Nota:SI desea instalar JupyterLab, simplemente reemplaza notebook por jupyterlab. . Primeros pasos . Notebook Server . Una vez que haya instalado Jupyter Notebook en su computadora, estará listo para ejecutar el servidor de la computadora portátil. Puede iniciar el servidor del portátil desde la línea de comandos (usando Terminal en Mac/Linux, Símbolo del sistema en Windows) ejecutando: . jupyter notebook . Esto imprimirá cierta información sobre el servidor en su terminal, incluida la URL de la aplicación web (de forma predeterminada, http://localhost:8888): . $ jupyter notebook [I 08:58:24.417 NotebookApp] Serving notebooks from local directory: /Users/catherine [I 08:58:24.417 NotebookApp] 0 active kernels [I 08:58:24.417 NotebookApp] The Jupyter Notebook is running at: http://localhost:8888/ [I 08:58:24.417 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). . A continuación, abrirá su navegador web predeterminado a esta URL. Cuando el notebook se abra en su navegador, verá el Panel, que mostrará una lista de notebooks, archivos y subdirectorios en el directorio donde se inició el servidor. . . La parte superior de la lista de notebooks se muestran rutas de navegación en las que se puede hacer clic del directorio actual. . Para crear un nuevo notebook, haga clic en el botón New en la parte superior de la lista y seleccione el kernel del menú desplegable (como se ve a continuación). Los kernels que se enumeran dependen de lo que esté instalado en el servidor. . Nota:Es posible que algunos de los kernels de la siguiente captura de pantalla no existan como una opción para usted. . . Una vez seleccionado el kernel, se abrira nuestro primer notebook!. . . Toolbox . Jupyter notebook nos ofrece el siguiente toolbox: . . File: En él, puede crear un nuevo cuaderno o abrir uno preexistente. Aquí es también a donde iría para cambiar el nombre de un Cuaderno. Creo que el elemento de menú más interesante es la opción Guardar y Checkpoint. Esto le permite crear puntos de control a los que puede retroceder si lo necesita. | . Edit: Aquí puede cortar, copiar y pegar celdas. Aquí también es donde irías si quisieras eliminar, dividir o fusionar una celda. Puede reordenar celdas aquí también. | . View: es útil para alternar la visibilidad del encabezado y la barra de herramientas. También puede activar o desactivar los números de línea dentro de las celdas. Aquí también es donde irías si quieres meterte con la barra de herramientas de la celda. | . Insert: es solo para insertar celdas encima o debajo de la celda seleccionada actualmente. | . Cell: le permite ejecutar una celda, un grupo de celdas o todas las celdas. También puede ir aquí para cambiar el tipo de celda, aunque personalmente considero que la barra de herramientas es más intuitiva para eso. | . Kernel: es para trabajar con el kernel que se ejecuta en segundo plano. Aquí puede reiniciar el kernel, volver a conectarlo, apagarlo o incluso cambiar el kernel que está utilizando su computadora portátil. | . Widgets: es para guardar y borrar el estado del widget. Los widgets son básicamente widgets de JavaScript que puede agregar a sus celdas para crear contenido dinámico utilizando Python (u otro Kernel). | . Help: es donde debe aprender sobre los atajos de teclado del Notebook, un recorrido por la interfaz de usuario y mucho material de referencia. | . Markdown . Jupyter Notebook permite que escribamos texto formateado, es decir, texto con cursiva, negritas, títulos de distintos tamaños, etc., de forma simple. Para ello Jupyter nos permite usar Markdown, que es un lenguaje de marcado (markup) muy popular. . Los lenguajes de markup son lenguajes ideados para procesar texto, algunos de los más conocidos son HTML y $ LaTeX$. Markdown tiene como objetivo ser un lenguaje de sintaxis minimalista, simple de aprender y usar; de esa forma uno puede dar formato al texto pero sin perder demasiado tiempo en los detalles. . La cantidad de tutoriales en la red sobre Markdown es inmenso, por lo que nos centraremos en indicar las opciones que más se utilizan. . Texto en negrita/cursiva: El texto en negrita se indica entre dos pares de asteriscos. De este modo **palabra** aparecerá como palabra. Por otro lado, el texto en cursiva se indica entre dos asteriscos simples; es decir *palabra* aparecerá como palabra. | . Listas: Las listas en Markdown se realizan indicando un asterisco o un número seguido de un punto si se desean listas numeradas. Markdown organiza automáticamente los items asignándoles el número correcto. | . Inclusión de imágenes: La sintaxis para incluir imágenes en Markdown es ![nombre alternativo](dirección de la imagen) en donde el nombre alternativo aparecerá en caso de que no se pueda cargar la imágen y la dirección puede referirse a una imagen local o un enlace en Internet. | . Inclusión de código HTML: El lenguaje Markdown es un subconjunto del lenguaje HTML y en donde se necesite un mayor control del formato, se puede incluir directamente el código HTML. | . Enlaces: Las celdas de texto pueden contener enlaces, tanto a otras partes del documento, como a páginas en internet u otros archivos locales. Su sintaxis es [texto](dirección del enlace). | . Fórmulas matemáticas: Gracias al uso de MathJax, se puede incluir código en $ LaTeX$ para mostrar todo tipo de fórmulas y expresiones matemáticas. Las fórmulas dentro de una línea de texto se escriben entre símbolos de dólar $...$, mientras que las expresiones separadas del texto utilizan símbolos de dólar dobles $$...$$. Los siguientes son ejemplos de fórmulas matemáticas escritas en $ LaTeX$: | . $$p(x) = 3x^2 + 5y^2 + x^2y^2$$ . $$e^{ pi i} - 1 = 0$$ . $$ lim_{x rightarrow infty} 3x+1$$ . $$ sum_{n=1}^ infty frac{1}{n^2}$$ . $$ int_0^ infty frac{ sin x}{x} , mathrm{d}x= frac{ pi}{2}$$ . C&#243;digo . Jupyter Notebook permite que escribamos código dependiendo del kernel a trabajar. Por defecto, se trabaja con el kernel de Python. . Veamos unos ejemplos sencillos de código: . import math n = 16 print(f&quot;La raiz cuadra de {n} es {math.sqrt(n)}&quot;) . La raiz cuadra de 16 es 4.0 . También es posible visualizar tablas de datos con la librería pandas: . import pandas as pd import altair as alt # datasets movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; . . df = pd.read_json(movies) # load movies data df.columns = [x.replace(&#39; &#39;, &#39;_&#39;) for x in df.columns.values] df.head() . Title US_Gross Worldwide_Gross US_DVD_Sales Production_Budget Release_Date MPAA_Rating Running_Time_min Distributor Source Major_Genre Creative_Type Director Rotten_Tomatoes_Rating IMDB_Rating IMDB_Votes . 0 The Land Girls | 146083.0 | 146083.0 | NaN | 8000000.0 | Jun 12 1998 | R | NaN | Gramercy | None | None | None | None | NaN | 6.1 | 1071.0 | . 1 First Love, Last Rites | 10876.0 | 10876.0 | NaN | 300000.0 | Aug 07 1998 | R | NaN | Strand | None | Drama | None | None | NaN | 6.9 | 207.0 | . 2 I Married a Strange Person | 203134.0 | 203134.0 | NaN | 250000.0 | Aug 28 1998 | None | NaN | Lionsgate | None | Comedy | None | None | NaN | 6.8 | 865.0 | . 3 Let&#39;s Talk About Sex | 373615.0 | 373615.0 | NaN | 300000.0 | Sep 11 1998 | None | NaN | Fine Line | None | Comedy | None | None | 13.0 | NaN | NaN | . 4 Slam | 1009819.0 | 1087521.0 | NaN | 1000000.0 | Oct 09 1998 | R | NaN | Trimark | Original Screenplay | Drama | Contemporary Fiction | None | 62.0 | 3.4 | 165.0 | . Unas de las cosas más significativas de Jupyter notebook es poder trabajar con distintos tipos de gráficos (imagen estática o interactiva). Estos son de bastante utilidad para poder comprender nuestros procedimientos. . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . . Completado mediantes Tabs. . La completación mediante tabs, especialmente para los atributos, es una forma conveniente de explorar la estructura de cualquier objeto con el que esté tratando. . Simplemente escriba object_name.&lt;TAB&gt; para ver los atributos del objeto. Además de los objetos y palabras clave de Python, la finalización de pestañas también funciona en nombres de archivos y directorios. . import collections collections. # aprete la tecla &lt;𝑇𝐴𝐵&gt; . Buscando ayuda . En caso de necesitar ayuda sobre cualquier comando de Python, Jupyter nos ofrece una función llamada help. . En resumen, ¡suele ser más importante saber como buscar información que memorizarla! Por todo esto, Jupyter nos ofrece ayuda sobre cualquier comando agregando un signo de interrogación ? luego del nombre del comando (y luego ejecutar la celda con la combinación de teclas SHIFT + ENTER). . import numpy as np np.sum? . Magics . Jupyter posee varias funciones mágicas predefinidas que sirven para simplificar tareas comunes. . Hay dos tipos de magias: . Magias por linea (line magics): son comandos que empiezan con el caracter % y que toman como argumentos valores escritos en la misma línea. | . Magias por celda (cell magics): son comandos que empiezan con los caracteres %%, y que reciben argumentos en la misma línea y en toda la celda. | . En general solo se puede usar una sola mágias por celda en cada celda y debe ser escrita en la primer linea de la celda. . Un buen ejemplo de mágia es %lsmagic que lista todas las magias disponibles: . %lsmagic . Available line magics: %alias %alias_magic %autoawait %autocall %automagic %autosave %bookmark %cat %cd %clear %colors %conda %config %connect_info %cp %debug %dhist %dirs %doctest_mode %ed %edit %env %gui %hist %history %killbgscripts %ldir %less %lf %lk %ll %load %load_ext %loadpy %logoff %logon %logstart %logstate %logstop %ls %lsmagic %lx %macro %magic %man %matplotlib %mkdir %more %mv %notebook %page %pastebin %pdb %pdef %pdoc %pfile %pinfo %pinfo2 %pip %popd %pprint %precision %prun %psearch %psource %pushd %pwd %pycat %pylab %qtconsole %quickref %recall %rehashx %reload_ext %rep %rerun %reset %reset_selective %rm %rmdir %run %save %sc %set_env %store %sx %system %tb %time %timeit %unalias %unload_ext %who %who_ls %whos %xdel %xmode Available cell magics: %%! %%HTML %%SVG %%bash %%capture %%debug %%file %%html %%javascript %%js %%latex %%markdown %%perl %%prun %%pypy %%python %%python2 %%python3 %%ruby %%script %%sh %%svg %%sx %%system %%time %%timeit %%writefile Automagic is ON, % prefix IS NOT needed for line magics. . En varias situaciones resulta necesario medir el tiempo de ejecución de una porción de código. Para ello podemos usar la magia %timeit. Esta magia está disponible tanto para línea como para celda: . %%timeit 1+1 # timeit repite (adaptativamente) la medición a fin de reducir el error. . 8.68 ns ± 0.387 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each) . Jupyter notebook permite también mezclar varios lenguajes de programación en una misma notebook. Por ejemplo, podríamos escribir en bash lo siguiente: . %%bash for i in {3..1}; do echo $i done echo &quot;Hola desde $BASH&quot; . 3 2 1 Hola desde /usr/bin/bash . También, puede acceder a la línea de comandos, anteponiendo el símbolo de !. Esto es de bastante utilidad cuando se quiere mostrar las dependencias que se necesitan instalar. (ejemplo: !pip install pandas). . Veamos un ejemplo: . !pwd . /home/fralfaro/PycharmProjects/ds_blog/_notebooks . Referencia . Notebook Basics | Running the Notebook | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/07/31/jupyter.html",
            "relUrl": "/jupyter/2021/07/31/jupyter.html",
            "date": " • Jul 31, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "TDD",
            "content": "Introducci&#243;n . Esta sección busca dar señales de cómo abordar el desarrollo de software para Data Science usando Test Driven Development, una técnica ampliamente usada en otros rubros de la programación. . &#191;Qu&#233; es el Test Driven Development? . En palabras simples, el desarrollo guiado por pruebas pone las pruebas en el corazón de nuestro trabajo. En su forma más simple consiste en un proceso iterativo de 3 fases: . . Red: Escribe un test que ponga a prueba una nueva funcionalidad y asegurate de que el test falla | Green: Escribe el código mínimo necesario para pasar ese test | Refactor: Refactoriza de ser necesario | . Ejemplo sencillo . A modo de ejemplo, vamos a testear la función paridad, que determina si un número natural es par o no. . Lo primero que se debe hacer es crear el test, para ello se ocupará la librería pytest. . Nota:No es necesario conocer previamente la librería pytest para entender el ejemplo. . @pytest.mark.parametrize( &quot;number, expected&quot;, [ (2, &#39;par&#39;), ]) def test_paridad(number, expected): assert paridad(number) == expected . El test nos dice que si el input es el número 2, la función paridad devuelve el output &#39;par&#39;. Cómo aún no hemos escrito la función, el test fallará (fase red). . ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py F [100%] ========= 1 failed in 0.14s =============================================== . Ahora, se escribe la función paridad (fase green): . def paridad(n:int)-&gt;str: &quot;&quot;&quot; Determina si un numero natural es par o no. :param n: numero entero :return: &#39;par&#39; si es el numero es par; &#39;impar&#39; en otro caso &quot;&quot;&quot; return &#39;par&#39; if n%2==0 else &#39;impar&#39; . Volvemos a correr el test: . ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py . [100%] ========= 1 passed in 0.06s =============================================== . Hemos cometido un descuido a proposito, no hemos testeado el caso si el número fuese impar, por lo cual reescribimos el test (fase refactor) . @pytest.mark.parametrize( &quot;number, expected&quot;, [ (2, &#39;par&#39;), (3, &#39;impar&#39;), ]) def test_paridad(number, expected): assert paridad(number) == expected . y corremos nuevamente los test: . ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 2 items temp/test_funcion.py .. [100%] ========= 2 passed in 0.06s =============================================== . Listo, nuestra función paridad ha sido testeado correctamente!. . &#191;Porqu&#233; deber&#237;a usarlo? . Existen varias razones por las que uno debería usar TDD. Entre ellas podemos encontrar: . Formular bien nuestros pensamientos mediante la escritura de un test significativo antes de ponernos a solucionar el problema nos ayuda a clarificar los límites del problema y cómo podemos resolverlo. Con el tiempo esto ayuda a obtener un diseño modular y reusable del código. | Escribir tests ayuda la forma en que escribimos código, haciéndolo más legible a otros. Sin embargo, no es un acto de altruismo, la mayoría de las veces ese otro es tu futuro yo. | Verifica que el código funciona de la manera que se espera, y lo hace de forma automática. | Te permite realizar refactoring con la certeza de que no has roto nada. | Los tests escritos sirven como documentación para otros desarrolladores. | Es una práctica requerida en metodologías de desarrollo de software agile. | . Evidencia emp&#237;rica . El 2008, Nagappan, Maximilien, Bhat y Williams publicaron el paper llamado Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams, en donde estudiaron 4 equipos de trabajo (3 de Microsoft y 1 de IBM), con proyectos que variaban entre las 6000 lineas de código hasta las 155k. Estas son parte de sus conclusiones: . Todos los equipos demostraron una baja considerable en la densidad de defectos:40% para el equipo de IBM, y entre 60-90% para los equipos de Microsoft. . Como todo en la vida, nada es gratis: . Incremento del tiempo de desarrollo varía entre un 15% a 35%. . Sin embargo . Desde un punto de vista de eficacia este incremento en tiempo de desarrollo se compensa por los costos de mantención reducidos debido al incremento en calidad. . Además, es importante escribir tests junto con la implementación en pequeñas iteraciones. George y Williams encontraron que escribir tests después de que la aplicación está mas o menos lista hace que se testee menos porque los desarrolladores piensan en menos casos, y además la aplicación se vuelve menos testeable. Otra conclusión interesante del estudio de George y Williams es que un 79% de los desarrolladores experimentaron que el uso de TDD conlleva a un diseño más simple. . &#191;Puedo usar TDD siempre? . No, pero puedes usarlo casi siempre. El análisis exploratorio es un caso en que el uso de TDD no hace sentido. Una vez que tenemos definido el problema a solucionar y un mejor entendimiento del problema podemos aterrizar nuestras ideas a la implementación vía testing. . Librer&#237;as disponibles . Acá listamos algunas librerías de TDD en Python: . unittest: Módulo dentro de la librería estándar de Python. Permite realizar tests unitarios, de integración y end to end. | doctest: Permite realizar test de la documentación del código (ejemplos: Numpy o Pandas). | pytest: Librería de testing ampliamente usada en proyectos nuevos de Python. | nose: Librería que extiende unittest para hacerlo más simple. | coverage: Herramienta para medir la cobertura de código de los proyectos. | tox: Herramienta para facilitar el test de una librería en diferentes versiones e intérpretes de Python. | hypothesis: Librería para escribir tests vía reglas que ayuda a encontrar casos borde. | behave: Permite utilizar Behavior Driven Development, un proceso de desarrollo derivado del TDD. | . Knowledge base / Lecturas recomendadas . Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams, es una buena lectura, sobretodo los consejos que dan en las conclusiones. | Google Testing Blog: Poseen varios artículos sobre cómo abordar problemas tipo, buenas prácticas de diseño para generar código testeable, entre otros. En particular destaca la serie Testing on the Toilet. | Cualquier artículo de Martin Fowler sobre testing, empezando por éste | Design Patterns: Los patrones de diseño de software tienen en consideración que el código sea testeable. | .",
            "url": "https://fralfaro.github.io/ds_blog/jupyter/2021/07/15/tdd.html",
            "relUrl": "/jupyter/2021/07/15/tdd.html",
            "date": " • Jul 15, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About me",
          "content": "Contact Information .   . Name: Francisco Antonio Alfaro Medina | Phone: +56 9 94541139 | Email: francisco.alfaro.496@gmail.com | Curriculum Vitae: link | . Personal Information . 🎮 Gaming | 🏀 Basketball | 💡 Learning | 📚 Teaching . Statistician and Teacher at Universidad Técnica Federico Santa María. I currently work as a Senior Data Scientist at ITAU (Bank). I enjoy programming, learning about different topics and teaching about maths and computer. . 🔍 Interests: . Software Development | Statistical Modelling | Machine/Deep Learning | Cloud computing | Big Data | Time Series | . My Tech Stack . Languages &amp; Frameworks .       . Cloud .   . Tools and Others .   . Certifications . .",
          "url": "https://fralfaro.github.io/ds_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Research & Talks",
          "content": "Research . 🧾 Alfaro,F. (2019). Estimation of the reciprocal effects between Happiness and Job Performance in Chile. Master thesis. | 🧾 Alfaro,F. (2018/2019). University retention about construction engineering students.Investigation. | 🧾 Alfaro,F. (2018). Spatial-statistics study for 3D Kriging (laboratory tests for tailings).Investigation. | 🧾 Alfaro,F. (2017). Fraud detection in drinking water consumption.Degree thesis. | . Talks . 💬 Alfaro,F. (2018). Estimation of the reciprocal effects between Happiness and Job Performance in Chile. FNE33/CLATSE13 Congress. Guadalajara, MX. | .",
          "url": "https://fralfaro.github.io/ds_blog/research/",
          "relUrl": "/research/",
          "date": ""
      }
      
  

  
  

  
  

  
      ,"page6": {
          "title": "Software",
          "content": "Python Packages . Python is an interpreted high-level general-purpose programming language. Python is used for web development, AI, machine learning, operating systems, mobile application development, and video games. I contribute as developer/maintainer of the following Python packages: . Note: The original projects was developed by Felipe Osorio. These repositories are only a packages transform from R to Python. . fastmatrix: Fast computation of some matrices useful in statistics .   . Yet another R package for matrices. It contains a small set of functions to fast computation of some matrices and operations useful in statistics. . HEAVY: Robust estimation using heavy-tailed distributions .   . Functions to perform robust estimation considering heavy-tailed distributions. Currently, the package includes linear regression, linear mixed-effect models, multivariate location and scatter estimation, multivariate regression, penalized splines and random variate generation. . L1pack: Routines for L1 Estimation .   . Provides routines to perform L1 estimation for linear regression, evaluation of density, distribution function, quantile function and random number generation for univariate and multivariate Laplace distribution. . MVT: Estimation and testing for the multivariate t-distribution .   . This package contains a set of routines to perform estimation and inference under the multivariate t-distribution. These methods are a direct generalization of the multivariate inference under the gaussian assumption. In addition, these procedures provide robust methods useful against outliers. . SpatialPack: Tools for assessment the association between two spatial processes .   . This package provides tools to assess the association between two spatial processes. Currently, four methodologies are implemented: A modified t-test to perform hypothesis testing about the independence between the processes, a suitable nonparametric correlation coefficient, the codispersion coefficient, and an F test for assessing the multiple correlation between one spatial process and several others. Functions for image processing and computing the spatial association between images are also provided. SpatialPack gives methods to complement methodologies that are available in geoR for one spatial process. .",
          "url": "https://fralfaro.github.io/ds_blog/software/",
          "relUrl": "/software/",
          "date": ""
      }
      
  

  
      ,"page7": {
          "title": "Teaching",
          "content": "Universities Courses . MAT281 - Applications of Mathematics in Engineering . University: Universidad Técnica Federico Santa María (UTFSM). | Course: Applications of Mathematics in Engineering. | Course abbreviation: MAT281. | Prerequisites: None. | Academic Unit that teaches it: Department of Mathematics. | Training axis: Applied Engineering and Integration. | Information: file. | Repository: 2019, 2020, 2021. | . Previous Courses . MAT021 - Calculus and Algebra I (UTFSM). | MAT022 - Calculus and Algebra II (UTFSM). | . Personal Courses . Basic Tools . Course: Basic Tools. | Description: Basic tools for Data Scientists. | Repository: link. | . Python Introduction . Course: Python Introduction. | Description: Basic concepts about Python. | Repository: link. | . Data Structures and Algorithms . Course: Data Structures and Algorithms. | Description: Data structures and algorithms with Python. | Repository: link. | . Data Manipulation . Course: Data Manipulation. | Description: Basic concepts about data manipulation wih Python (Numpy, Panda, Matplotlib). | Repository: link. | . Machine Learning . Course: Machine Learning. | Description: Basic concepts about Machine Learning (numpy, pandas, scikit-learn). | Repository: link. | . Deep Learning . Course: Deep Learning. | Description: Basic concepts about Deep Learning with Tensorflow and Keras. | Repository: link. | . Big Data . Course: Big Data | Description: Basic concepts about Big Data with Pyspark | Repository: link | . Software Design I . Course: Software Design I. | Description: Basic concepts about software design (version control, testing, and automatic build management). | Repository: link. | . Software Design II . Course: Software Design II. | Description: Advanced concepts about software design (version control, testing, and automatic build management). | Repository: link. | .",
          "url": "https://fralfaro.github.io/ds_blog/teaching/",
          "relUrl": "/teaching/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fralfaro.github.io/ds_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}